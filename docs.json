[{"name":"NameVisitor","comment":" Visit each name in the module.\n\nA \"name\" is a `Node ( ModuleName, String )` and represents a value or type reference. Here are some examples:\n\n  - `Json.Encode.Value` -> `( [ \"Json\", \"Encode\" ], \"Value\" )`\n  - `Html.Attributes.class` -> `( [ \"Html\", \"Attributes\" ], \"class\" )`\n  - `Page` -> `( [], \"Page\" )`\n  - `view` -> `( [], \"view\" )`\n\nThese can appear in many places throughout declarations and expressions, and picking them out each time is a lot of work. Instead of writing 1000 lines of code and tests each time, you can write one `nameVisitor` and plug it straight into your module schema, or separate `valueVisitor` and `typeVisitor`s.\n\n@docs withNameVisitor, withValueVisitor, withTypeVisitor, withValueAndTypeVisitors\n\n\n## Scope\n\nThis makes no attempt to resolve module names from imports, it just returns what's written in the code. It would be trivial to connect [elm-review-scope] with the name visitor if you want to do this.\n\n[elm-review-scope]: http://github.com/jfmengels/elm-review-scope/\n\n","unions":[],"aliases":[],"values":[{"name":"withNameVisitor","comment":" This will apply the `nameVisitor` to every value and type in the module, you will get no information about whether the name is a value or type.\n\n    rule : Rule\n    rule =\n        Rule.newModuleRuleSchema \"NoInconsistentAliases\" initialContext\n            |> NameVisitor.withNameVisitor nameVisitor\n            |> Rule.fromModuleRuleSchema\n\n    nameVisitor : Node ( ModuleName, String ) -> context -> ( List (Error {}), context )\n    nameVisitor node context =\n        -- Do what you want with the name\n        ( [], context )\n\n","type":"(Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context )) -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : () } context -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : (), hasAtLeastOneVisitor : () } context"},{"name":"withTypeVisitor","comment":" This will apply the `typeVisitor` to every type in the module, and ignore any values.\n\n    rule : Rule\n    rule =\n        Rule.newModuleRuleSchema \"NoInconsistentAliases\" initialContext\n            |> NameVisitor.withTypeVisitor typeVisitor\n            |> Rule.fromModuleRuleSchema\n\n    typeVisitor : Node ( ModuleName, String ) -> context -> ( List (Error {}), context )\n    typeVisitor node context =\n        -- Do what you want with the type\n        ( [], context )\n\n","type":"(Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context )) -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : () } context -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : (), hasAtLeastOneVisitor : () } context"},{"name":"withValueAndTypeVisitors","comment":" This will apply the `valueVisitor` to every value and the `typeVisitor` to every type in the module.\n\n    rule : Rule\n    rule =\n        Rule.newModuleRuleSchema \"NoInconsistentAliases\" initialContext\n            |> NameVisitor.withValueAndTypeVisitors\n                { valueVisitor = valueVisitor\n                , typeVisitor = typeVisitor\n                }\n            |> Rule.fromModuleRuleSchema\n\n    valueVisitor : Node ( ModuleName, String ) -> context -> ( List (Error {}), context )\n    valueVisitor node context =\n        -- Do what you want with the value\n        ( [], context )\n\n    typeVisitor : Node ( ModuleName, String ) -> context -> ( List (Error {}), context )\n    typeVisitor node context =\n        -- Do what you want with the type\n        ( [], context )\n\n","type":"{ valueVisitor : Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context ), typeVisitor : Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context ) } -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : () } context -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : (), hasAtLeastOneVisitor : () } context"},{"name":"withValueVisitor","comment":" This will apply the `valueVisitor` to every value in the module, and ignore any types.\n\n    rule : Rule\n    rule =\n        Rule.newModuleRuleSchema \"NoInconsistentAliases\" initialContext\n            |> NameVisitor.withValueVisitor valueVisitor\n            |> Rule.fromModuleRuleSchema\n\n    valueVisitor : Node ( ModuleName, String ) -> context -> ( List (Error {}), context )\n    valueVisitor node context =\n        -- Do what you want with the value\n        ( [], context )\n\n","type":"(Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String ) -> context -> ( List.List (Review.Rule.Error {}), context )) -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : () } context -> Review.Rule.ModuleRuleSchema { schemaState | canCollectProjectData : (), hasAtLeastOneVisitor : () } context"}],"binops":[]}]